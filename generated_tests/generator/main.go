package main

import (
	"flag"
	"fmt"
	"github.com/pkg/errors"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var outputDir = flag.String("output_dir", ".", "Output directory for generated test files")

var testCases = []struct{
	Name string
	Type string
	TagValue1 string // A valid pdefault tag - e.g. 10
	Literal1 string // Literal value equal to TagValue1 - e.g. int64(10)
	TagValue2 string // A valid pdefault tag - e.g. 20
	Literal2 string // Literal value equal to TagValue2 - e.g. int64(20)
	Literal3 string // Literal value not equal to TagValues 1 or 2 - e.g. int64(30)
	OverflowValue string // Tag value which will overflow this type - if blank overflow tests will not run
}{
	{
		Name: "Float32",
		Type: "float32",
		TagValue1: "1.1",
		Literal1: "float32(1.1)",
		TagValue2: "2.2",
		Literal2: "float32(2.2)",
		Literal3: "float32(3.3)",
		OverflowValue: "1e50",
	},
	{
		Name: "Float64",
		Type: "float64",
		TagValue1: "1.1",
		Literal1: "float64(1.1)",
		TagValue2: "2.2",
		Literal2: "float64(2.2)",
		Literal3: "float64(3.3)",
	},
	{
		Name: "Int",
		Type: "int",
		TagValue1: "10",
		Literal1: "int(10)",
		TagValue2: "-20",
		Literal2: "int(-20)",
		Literal3: "int(30)",
	},
	{
		Name: "Int8",
		Type: "int8",
		TagValue1: "10",
		Literal1: "int8(10)",
		TagValue2: "-20",
		Literal2: "int8(-20)",
		Literal3: "int8(30)",
	},
	{
		Name: "Int16",
		Type: "int16",
		TagValue1: "10",
		Literal1: "int16(10)",
		TagValue2: "-20",
		Literal2: "int16(-20)",
		Literal3: "int16(30)",
	},
	{
		Name: "Int32",
		Type: "int32",
		TagValue1: "10",
		Literal1: "int32(10)",
		TagValue2: "-20",
		Literal2: "int32(-20)",
		Literal3: "int32(30)",
	},
	{
		Name: "Int64",
		Type: "int64",
		TagValue1: "10",
		Literal1: "int64(10)",
		TagValue2: "-20",
		Literal2: "int64(-20)",
		Literal3: "int64(30)",
	},
	{
		Name: "String",
		Type: "string",
		TagValue1: "hello",
		Literal1: "\"hello\"",
		TagValue2: "world",
		Literal2: "\"world\"",
		Literal3: "\"some\"",
	},
	{
		Name: "Uint",
		Type: "uint",
		TagValue1: "10",
		Literal1: "uint(10)",
		TagValue2: "20",
		Literal2: "uint(20)",
		Literal3: "uint(30)",
	},
	{
		Name: "Uint8",
		Type: "uint8",
		TagValue1: "10",
		Literal1: "uint8(10)",
		TagValue2: "20",
		Literal2: "uint8(20)",
		Literal3: "uint8(30)",
	},
	{
		Name: "Uint16",
		Type: "uint16",
		TagValue1: "10",
		Literal1: "uint16(10)",
		TagValue2: "20",
		Literal2: "uint16(20)",
		Literal3: "uint16(30)",
	},
	{
		Name: "Uint32",
		Type: "uint32",
		TagValue1: "10",
		Literal1: "uint32(10)",
		TagValue2: "20",
		Literal2: "uint32(20)",
		Literal3: "uint32(30)",
	},
	{
		Name: "Uint64",
		Type: "uint64",
		TagValue1: "10",
		Literal1: "uint64(10)",
		TagValue2: "20",
		Literal2: "uint64(20)",
		Literal3: "uint64(30)",
	},
}

func main() {
	flag.Parse()

  t := template.Must(template.New("queue").Parse(testTemplate))

  for _, testCase := range testCases {

		outFileName := filepath.Join(*outputDir, fmt.Sprintf("%s_test.go", strings.ToLower(testCase.Name)))
		outFile, err := os.Create(outFileName)
		if err != nil {
			log.Fatalf("Error opening output file %q: %v", outFileName, err)
		}

		err = t.Execute(outFile, testCase)
		if err != nil {
			panic(errors.Wrapf(err, "Failed to generate test case %q", outFileName))
		}
	}
}

var testTemplate =
`// Code generated by pdefault/generated_tests/generator. DO NOT EDIT.

package generated_tests

import (
	"github.com/stretchr/testify/assert"
	"github.com/thecodedproject/pdefault"
	"reflect"
	"testing"
)

func Test_{{.Name}}_InitalisesFieldWhenNotSet(t *testing.T) {
	type TestStruct struct {
		Field *{{.Type}} ` + "`pdefault:\"{{.TagValue1}}\"`" + `
	}

	input := TestStruct{}
	val := {{.Literal1}}
	expected := TestStruct{
		Field: &val,
	}

	pdefault.Init(&input)

	assert.Equal(t, expected, input)
}

func Test_{{.Name}}_InitalisesMultipleFieldWhenNotSet(t *testing.T) {
	type TestStruct struct {
		Field1 *{{.Type}} ` + "`pdefault:\"{{.TagValue1}}\"`" + `
		Field2 *{{.Type}} ` + "`pdefault:\"{{.TagValue2}}\"`" + `
	}

	input := TestStruct{}
	val1 := {{.Literal1}}
	val2 := {{.Literal2}}
	expected := TestStruct{
		Field1: &val1,
		Field2: &val2,
	}

	pdefault.Init(&input)

	assert.Equal(t, expected, input)
}

func Test_{{.Name}}_InitalisesMultipleFieldWhenAllAreSet(t *testing.T) {
	type TestStruct struct {
		Field1 *{{.Type}} ` + "`pdefault:\"{{.TagValue1}}\"`" + `
		Field2 *{{.Type}} ` + "`pdefault:\"{{.TagValue2}}\"`" + `
	}

	val1 := {{.Literal3}}
	val2 := {{.Literal3}}
	input := TestStruct{
		Field1: &val1,
		Field2: &val2,
	}
	expected := TestStruct{
		Field1: &val1,
		Field2: &val2,
	}

	pdefault.Init(&input)

	assert.Equal(t, expected, input)
}

func Test_{{.Name}}_InitalisesMultipleFieldWhenSomeAreSet(t *testing.T) {
	type TestStruct struct {
		Field1 *{{.Type}} ` + "`pdefault:\"{{.TagValue1}}\"`" + `
		Field2 *{{.Type}} ` + "`pdefault:\"{{.TagValue2}}\"`" + `
	}

	val1 := {{.Literal3}}
	input := TestStruct{
		Field1: &val1,
	}
	val2 := {{.Literal2}}
	expected := TestStruct{
		Field1: &val1,
		Field2: &val2,
	}

	pdefault.Init(&input)

	assert.Equal(t, expected, input)
}

func Test_{{.Name}}_NonPointerFieldsWithoutPdefaultAreIgnored(t *testing.T) {
	type TestStruct struct {
		Field1 *{{.Type}} ` + "`pdefault:\"{{.TagValue1}}\"`" + `
		NonPointerField float64
	}

	input := TestStruct{
		NonPointerField: 1.0,
	}

	val := {{.Literal1}}
	expected := TestStruct{
		Field1: &val,
		NonPointerField: 1.0,
	}

	pdefault.Init(&input)

	assert.Equal(t, expected, input)
}

func Test_{{.Name}}_WhenDefaultNotConvertibleToIntPanicsWhenFieldNil(t *testing.T) {

	// Do not perform this test on strings since a tag will always be convertable
	// to a string type.
	if reflect.TypeOf({{.Literal1}}).Kind() != reflect.String {
		type TestStruct struct {
			Field1 *{{.Type}} ` + "`pdefault:\"someString\"`" + `
		}

		input := TestStruct{
		}

		defer func() {
			if panicErr := recover(); panicErr != nil {
				assert.Regexp(t, "(.*someString)(.*{{.Type}})(.*Field1)", panicErr, "Error should contain the field name")
			} else {
				assert.Fail(t, "Did not panic")
			}
		}()

		pdefault.Init(&input)
	}
}

func Test_{{.Name}}_WhenDefaultNotConvertibleToIntPanicsWhenFieldNotNil(t *testing.T) {

	// Do not perform this test on strings since a tag will always be convertable
	// to a string type.
	if reflect.TypeOf({{.Literal1}}).Kind() != reflect.String {
		type TestStruct struct {
			Field1 *{{.Type}} ` + "`pdefault:\"hello\"`" + `
		}

		val := {{.Literal1}}
		input := TestStruct{
			Field1: &val,
		}

		defer func() {
			if panicErr := recover(); panicErr != nil {
				assert.Regexp(t, "(.*hello)(.*{{.Type}})(.*Field1)", panicErr, "Error should contain the field name")
			} else {
				assert.Fail(t, "Did not panic")
			}
		}()

		pdefault.Init(&input)
	}
}

func Test_{{.Name}}_PdefaultTagOnNotPointerFieldPanics(t *testing.T) {

	type TestStruct struct {
		NonPointerField {{.Type}} ` + "`pdefault:\"{{.TagValue1}}\"`" + `
	}

	input := TestStruct{
	}

	defer func() {
		if panicErr := recover(); panicErr != nil {
			assert.Regexp(t, "NonPointerField", panicErr, "Error should contain the field name")
		} else {
			assert.Fail(t, "Did not panic")
		}
	}()

	pdefault.Init(&input)
}

func Test_{{.Name}}_PanicsWithFieldNameIfDefaultValueOverflows(t *testing.T) {
	if "{{.OverflowValue}}" != "" {
		assert.Fail(t, "some")

		type TestStruct struct {
			Field1 *{{.Type}} ` + "`pdefault:\"{{.OverflowValue}}\"`" + `
		}

		input := TestStruct{
		}

		defer func() {
			if panicErr := recover(); panicErr != nil {
				assert.Regexp(t, ".*Field1", panicErr, "Error should contain the field name")
			} else {
				assert.Fail(t, "Did not panic")
			}
		}()

		pdefault.Init(&input)

	}
}
`
